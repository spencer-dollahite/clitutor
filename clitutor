#!/usr/bin/env bash

clear
echo " ██████╗██╗     ██╗████████╗██╗   ██╗████████╗ ██████╗ ██████╗ ";
echo "██╔════╝██║     ██║╚══██╔══╝██║   ██║╚══██╔══╝██╔═══██╗██╔══██╗";
echo "██║     ██║     ██║   ██║   ██║   ██║   ██║   ██║   ██║██████╔╝";
echo "██║     ██║     ██║   ██║   ██║   ██║   ██║   ██║   ██║██╔══██╗";
echo "╚██████╗███████╗██║   ██║   ╚██████╔╝   ██║   ╚██████╔╝██║  ██║";
echo " ╚═════╝╚══════╝╚═╝   ╚═╝    ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═╝";
echo
echo "Welcome to clitutor! You are on the cusp of an exciting journey."
echo
echo "Why learn the cli (Command Line Interface)?"
echo
echo "Both Windows and Linux/UNIX systems can be easily managed at scale via automation by using text-only commands rather than clicking around icons in a GUI (Graphical User Interface). Knowing your way around the CLI will let you operate expertly and efficiently around systems for both defensive and offensive operations."
echo 
echo "We will focus on non-Windows CLI. Over 90% of workloads on the internet/in 'the cloud' run on Linux/Unix systems, so this skillset is widely applicable when administering infrastructure."
echo "Type 'pwd' (without the quotes) below to see where you currently are."
printf "Hint: \e[4mp\e[0mrint \e[4mw\e[0mowrking \e[4md\e[0mirectory - you can think of a directory as the same thing as a folder\n\n"

while true; do
 read -p "\$ " user_input
 if [[ "$user_input" == "pwd" ]]; then
  pwd
  echo
  echo "^^^^^^^"
  echo "Nice! You just printed your current directory."
  echo "Think of this as the folder you’re currently 'in'."
  echo "From here, you can run 'ls' to list the files and directories inside."
  break
 else
  echo "That’s not quite right. Try typing: pwd"
 fi
done

while true; do
 read -p "\$ " user_input
 if [[ "$user_input" == "ls" ]]; then
  ls
  echo
  echo "^^^^^^^"
  echo "Those are the files and folders inside the folder path shown above."
  printf "Hint: \e[4ml\e[0mist \e[4ms\e[0mtorage\n\n"
  break
 else
  echo "That’s not quite right. Try typing: pwd"
 fi
done


while true; do
 read -p "Type 'c' to continue> " user_input
 if [[ "$user_input" == "c" ]]; then
  clear
  printf "From here, you can cd (\e[4mc\e[0mhange \e[4md\e[0mirectory) to other places. Below is a list of examples. The '/' is the root or top of the filesystem. These are known as absolute paths.\n\n"
  echo
  break
 else
  echo "That’s not quite right. Try typing: pwd"
 fi
done

find ~ -maxdepth 3 -not -path '*/.*' 2>/dev/null|head -n 5
find /etc/* -maxdepth 3 -not -path '*/.*' 2>/dev/null|head -n 5

echo 
echo "Type 'cd /' below to change to the root." 
echo "Then print the working directory to see where you end up."
echo "Then, do an 'ls' there to see what is hanging off the root of your filesystem."
echo "Finally, enter 'cd -' to return back to where you were last. 'cd -' can be used to toggle between two locations quickly."

while true; do
 read -p "\$ " user_input
 if [[ "$user_input" == "cd /" ]]; then
  cd /
  echo
  break
 else
  echo "That’s not quite right. Try typing: pwd"
 fi
done

while true; do
 read -p "\$ " user_input
 if [[ "$user_input" == "pwd" ]]; then
  pwd
  echo
  break
 else
  echo "That’s not quite right. Try typing: pwd"
 fi
done

while true; do
 read -p "\$ " user_input
 if [[ "$user_input" == "ls" ]]; then
  ls
  echo
  break
 else
  echo "That’s not quite right. Try typing: pwd"
 fi
done

while true; do
 read -p "\$ " user_input
 if [[ "$user_input" == "cd -" ]]; then
  cd -
  echo
  break
 else
  echo "That’s not quite right. Try typing: pwd"
 fi
done

echo "'.' refers to the current directory"
echo "'..' refers to the parent directory"
echo "'~' refers to the logged-in user's home directory"
echo "'ls -a' will show you hidden files. Anything that starts with a '.' is hidden by default"
echo "'cd ..' would move your working directory up one level to the parent"
echo "'cd ../..' would take you up two levels. So on and so forth"
echo
echo "'cd ~' would take you to your home directory. 'cd' by itself will do the same thing."
echo "'cd ~/<directory>' where <directory> is inside your home directory would take you to that path: /home/<user>/<directory>"
echo 
echo
echo "show a listing, including hidden items, where you are now"

while true; do
 read -p "\$ " user_input
 if [[ "$user_input" == "ls -a" ]]; then
  ls -a
  echo
  break
 else
  echo "That’s not quite right. Try typing: pwd"
 fi
done

echo "To view the contents of a text file, use 'less <filename>'"
echo "Show the contents of the next-steps file"

while true; do
 read -p "\$ " user_input
 if [[ "$user_input" == "less next-steps" ]]; then
  less next-steps
  echo
  break
 else
  echo "That’s not quite right. Try typing: pwd"
 fi
done

clear
echo
echo "Now, you'll be dropped out of this sandbox that is clitutor back into your proper environment. Start maneuvering around by doing listings and changing into other directories to gain some situational awareness of what is here."
echo
echo "You may notice filenames are case-sensitive. 'next-steps' is a real file. 'Next-steps' would be an entirely different file. It does not exist."
echo
echo "You may also find tab completion useful. After typing a few letters, hit the TAB key once. The word MAY auto-complete IF it is unique. If it is NOT unique, then you can hit the TAB key twice in quick succession. This should give you the options that start with the letters you have typed so far. You can then choose the next few letters to continue narrowing down the list until it IS unique in which case TAB will complete it. IF this behavior does not work on your system, then do some research online to determine how to install what is necessary on your system to get it working. It is a HUGE quality of life thing that you will want to be able to use."
