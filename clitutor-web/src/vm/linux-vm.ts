/**
 * v86 wrapper: boot Alpine Linux, serial I/O, file read/write.
 *
 * Uses the official v86 approach: i386 Alpine rootfs served via 9p over HTTP,
 * with bzImage/initramfs loaded from the filesystem. A state snapshot enables
 * near-instant boot on return visits.
 */

import { generateBashrc } from "./bashrc";

export interface LinuxVMOptions {
  wasmPath?: string;
  biosPath?: string;
  vgaBiosPath?: string;
  /** Base URL for 9p flat filesystem (content-addressed files). */
  fsBaseUrl?: string;
  /** Path to fs.json manifest generated by fs2json.py. */
  fsManifest?: string;
  /** Path to pre-booted state snapshot (optional, enables fast boot). */
  statePath?: string;
  /** Memory in bytes. 512 MB works well for Alpine. */
  memorySize?: number;
  /** Network relay WebSocket URL (null = no networking). */
  networkRelay?: string | null;
}

const DEFAULT_OPTS: Required<LinuxVMOptions> = {
  wasmPath: "/v86/v86.wasm",
  biosPath: "/v86/seabios.bin",
  vgaBiosPath: "/v86/vgabios.bin",
  fsBaseUrl: "/v86/alpine-rootfs-flat/",
  fsManifest: "/v86/alpine-fs.json",
  statePath: "/v86/alpine-state.bin",
  memorySize: 512 * 1024 * 1024,
  networkRelay: null,
};

/**
 * Kernel cmdline for 9p root mount.
 * - root=host9p: mount the v86 9p share as root
 * - rootfstype=9p: use 9p filesystem driver
 * - rootflags: virtio transport, loose caching for performance
 * - modules=virtio_pci: load virtio PCI driver in initramfs
 * - tsc=reliable: trust the TSC (avoids slowdowns from TSC calibration)
 * - console=ttyS0: serial console output
 */
const KERNEL_CMDLINE =
  "rw root=host9p rootfstype=9p rootflags=trans=virtio,cache=loose " +
  "modules=virtio_pci tsc=reliable console=ttyS0";

export class LinuxVM {
  private emulator: V86 | null = null;
  private opts: Required<LinuxVMOptions>;
  private onSerialByte: ((byte: number) => void) | null = null;
  private bootResolve: (() => void) | null = null;
  private serialText = "";
  private bashrcInstalled = false;

  constructor(opts: LinuxVMOptions = {}) {
    this.opts = { ...DEFAULT_OPTS, ...opts };
  }

  /**
   * Boot the VM. Returns once the emulator is started (not once the shell
   * is ready — use onReady callback for that).
   */
  async boot(onSerial: (byte: number) => void): Promise<void> {
    console.log("[LinuxVM] boot() called");
    this.onSerialByte = onSerial;

    console.log("[LinuxVM] Checking for state snapshot at:", this.opts.statePath);
    const hasState = await this.urlExists(this.opts.statePath);
    console.log("[LinuxVM] hasState:", hasState);

    console.log("[LinuxVM] Checking for fs manifest at:", this.opts.fsManifest);
    const hasFs = await this.urlExists(this.opts.fsManifest);
    console.log("[LinuxVM] hasFs:", hasFs);

    if (!hasFs) {
      console.error("[LinuxVM] FATAL: Alpine rootfs not found at", this.opts.fsManifest);
      throw new Error(
        "Alpine rootfs not found. Run 'npm run build-rootfs' first. " +
        `Expected: ${this.opts.fsManifest}`,
      );
    }

    // Hidden VGA container required by v86 internals even for serial-only
    let screenContainer = document.getElementById("v86-screen");
    if (!screenContainer) {
      console.log("[LinuxVM] Creating hidden v86-screen container");
      screenContainer = document.createElement("div");
      screenContainer.id = "v86-screen";
      screenContainer.style.display = "none";
      screenContainer.innerHTML =
        '<div style="white-space:pre;font:14px monospace;line-height:14px"></div>' +
        '<canvas style="display:none"></canvas>';
      document.body.appendChild(screenContainer);
    } else {
      console.log("[LinuxVM] Reusing existing v86-screen container");
    }

    const v86Options: V86Options = {
      wasm_path: this.opts.wasmPath,
      memory_size: this.opts.memorySize,
      vga_memory_size: 8 * 1024 * 1024,
      screen_container: screenContainer,
      disable_keyboard: true,
      disable_mouse: true,
      disable_speaker: true,
      acpi: false,
      autostart: true,
      bios: { url: this.opts.biosPath },
      vga_bios: { url: this.opts.vgaBiosPath },
      filesystem: {
        baseurl: this.opts.fsBaseUrl,
        basefs: this.opts.fsManifest,
      },
    };

    if (hasState) {
      console.log("[LinuxVM] Using state snapshot for instant boot");
      v86Options.initial_state = { url: this.opts.statePath };
    } else {
      console.log("[LinuxVM] Cold boot: bzimage_initrd_from_filesystem");
      v86Options.bzimage_initrd_from_filesystem = true;
      v86Options.cmdline = KERNEL_CMDLINE;
    }

    if (this.opts.networkRelay) {
      v86Options.network_relay_url = this.opts.networkRelay;
    }

    console.log("[LinuxVM] Creating V86 instance with options:", {
      wasm_path: v86Options.wasm_path,
      memory_size: v86Options.memory_size,
      hasInitialState: !!v86Options.initial_state,
      hasBzimage: !!v86Options.bzimage_initrd_from_filesystem,
      fsBaseUrl: this.opts.fsBaseUrl,
    });

    try {
      this.emulator = new V86(v86Options);
      console.log("[LinuxVM] V86 instance created successfully");
    } catch (err) {
      console.error("[LinuxVM] FAILED to create V86 instance:", err);
      throw err;
    }

    // Expose on window for state snapshot generation
    (window as any).__vm = this.emulator;

    // Wire serial output
    let serialByteCount = 0;
    this.emulator.add_listener("serial0-output-byte", (byte: number) => {
      serialByteCount++;
      if (serialByteCount === 1) {
        console.log("[LinuxVM] *** FIRST serial byte received! ***");
      }
      if (serialByteCount <= 10 || serialByteCount % 5000 === 0) {
        console.log("[LinuxVM] serial byte #%d: charCode=%d char=%s",
          serialByteCount, byte, JSON.stringify(String.fromCharCode(byte)));
      }
      this.onSerialByte?.(byte);

      // Track serial text to detect shell prompt for auto-setup
      this.serialText += String.fromCharCode(byte);
      if (this.serialText.length > 500) {
        this.serialText = this.serialText.slice(-200);
      }
      this.checkReady();
    });

    // Also listen for emulator events to debug lifecycle
    this.emulator.add_listener("emulator-ready", () => {
      console.log("[LinuxVM] EVENT: emulator-ready");
    });
    this.emulator.add_listener("emulator-started", () => {
      console.log("[LinuxVM] EVENT: emulator-started");
    });
    this.emulator.add_listener("emulator-stopped", () => {
      console.log("[LinuxVM] EVENT: emulator-stopped");
    });
    this.emulator.add_listener("emulator-loading", (e: any) => {
      console.log("[LinuxVM] EVENT: emulator-loading", e);
    });

    // When restoring from snapshot, the shell is idle — send Enter to
    // trigger a prompt reprint so checkReady() can detect it
    if (hasState) {
      setTimeout(() => {
        console.log("[LinuxVM] Sending newline to wake shell after snapshot restore");
        this.emulator?.serial0_send("\n");
      }, 1000);
    }

    // Diagnostic: check if emulator is running after a short delay
    setTimeout(() => {
      if (this.emulator) {
        const running = this.emulator.is_running?.();
        console.log("[LinuxVM] Diagnostic after 2s — is_running: %s, serial bytes received: %d",
          running, serialByteCount);
      }
    }, 2000);

    console.log("[LinuxVM] boot() complete — emulator created, listeners attached");
  }

  /**
   * Wait until the shell prompt appears, then install our custom bashrc.
   * Call this after boot() to set up the sentinel machinery.
   */
  waitForShell(): Promise<void> {
    console.log("[LinuxVM] waitForShell() called, bashrcInstalled:", this.bashrcInstalled);
    console.log("[LinuxVM] serialText so far (%d chars): %s",
      this.serialText.length, JSON.stringify(this.serialText.slice(-200)));
    return new Promise((resolve) => {
      if (this.bashrcInstalled) {
        console.log("[LinuxVM] waitForShell() — bashrc already installed, resolving immediately");
        resolve();
        return;
      }
      this.bootResolve = resolve;
      // Check immediately in case we already have a prompt
      this.checkReady();

      // Diagnostic: log serial progress every 3 seconds
      const diagInterval = setInterval(() => {
        if (this.bashrcInstalled) {
          clearInterval(diagInterval);
          return;
        }
        console.log("[LinuxVM] waitForShell STILL WAITING — serialText length: %d, tail: %s",
          this.serialText.length, JSON.stringify(this.serialText.slice(-150)));
      }, 3000);

      // Clear the diagnostic interval once resolved
      const origResolve = resolve;
      this.bootResolve = () => {
        clearInterval(diagInterval);
        origResolve();
      };
    });
  }

  private checkReady(): void {
    if (this.bashrcInstalled || !this.bootResolve) return;

    if (
      this.serialText.includes("localhost:~#") ||
      this.serialText.includes("clitutor:~#") ||
      this.serialText.includes("localhost login:") ||
      this.serialText.includes("~ #") ||
      this.serialText.includes(":~$ ") ||
      /\n(localhost|clitutor)[^ ]*[#$] $/.test(this.serialText)
    ) {
      console.log("[LinuxVM] checkReady(): shell prompt detected!");
      console.log("[LinuxVM] serialText tail:", JSON.stringify(this.serialText.slice(-100)));
      this.installBashrcNow();
    }
  }

  private async installBashrcNow(): Promise<void> {
    if (this.bashrcInstalled) return;
    this.bashrcInstalled = true;
    console.log("[LinuxVM] installBashrcNow(): starting bashrc installation");

    // Small delay for prompt to settle
    await new Promise((r) => setTimeout(r, 500));

    // Ensure /home/student exists before writing bashrc
    this.sendSerial("mkdir -p /home/student\n");
    await new Promise((r) => setTimeout(r, 300));

    // Write custom bashrc, source it (suppressing any errors), and clear
    // the terminal so boot noise is hidden when the overlay lifts
    const bashrc = generateBashrc("/home/student", "student", "clitutor");
    console.log("[LinuxVM] Writing bashrc to /home/student/.clitutor_bashrc (%d bytes)", bashrc.length);
    await this.writeFile("/home/student/.clitutor_bashrc", bashrc);
    console.log("[LinuxVM] Sending bashrc source command");
    this.sendSerial(". /home/student/.clitutor_bashrc 2>/dev/null; clear\n");

    // Mark VM as ready
    (window as any).__vmReady = true;

    // Resolve the waitForShell promise
    if (this.bootResolve) {
      console.log("[LinuxVM] Resolving waitForShell promise in 800ms");
      // Give bashrc a moment to take effect
      setTimeout(() => {
        console.log("[LinuxVM] waitForShell resolved — VM fully ready");
        this.bootResolve?.();
        this.bootResolve = null;
      }, 800);
    }
  }

  // ── Serial I/O ────────────────────────────────────────────────────

  sendSerial(data: string): void {
    if (!this.emulator) return;
    this.emulator.serial0_send(data);
  }

  sendSerialBytes(bytes: number[]): void {
    if (!this.emulator) return;
    for (const b of bytes) {
      this.emulator.serial0_send(String.fromCharCode(b));
    }
  }

  // ── Filesystem operations ─────────────────────────────────────────

  async writeFile(path: string, content: string): Promise<void> {
    if (!this.emulator) return;
    const encoder = new TextEncoder();
    await this.emulator.create_file(path, encoder.encode(content));
  }

  async readFile(path: string): Promise<string> {
    if (!this.emulator) return "";
    try {
      const data = await this.emulator.read_file(path);
      return new TextDecoder().decode(data);
    } catch {
      return "";
    }
  }

  async fileExists(path: string): Promise<boolean> {
    if (!this.emulator) return false;
    try {
      await this.emulator.read_file(path);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Run a command via serial and read result from a temp file.
   * Used for filesystem validation checks (not for interactive commands).
   */
  async execCommand(cmd: string): Promise<string> {
    const tag = `_ct_${Date.now()}`;
    const outFile = `/tmp/${tag}`;

    this.sendSerial(`${cmd} > ${outFile} 2>&1\n`);
    await new Promise((r) => setTimeout(r, 500));
    const result = await this.readFile(outFile);
    this.sendSerial(`rm -f ${outFile}\n`);
    return result;
  }

  async hasDirWithFile(root: string): Promise<boolean> {
    const result = await this.execCommand(
      `find ${root} -mindepth 2 -maxdepth 2 -type f 2>/dev/null | head -1`,
    );
    return result.trim().length > 0;
  }

  async findFileContaining(root: string, text: string): Promise<boolean> {
    const escaped = text.replace(/'/g, "'\\''");
    const result = await this.execCommand(
      `grep -rl '${escaped}' ${root} 2>/dev/null | head -1`,
    );
    return result.trim().length > 0;
  }

  async seedFiles(commands: string[]): Promise<void> {
    for (const cmd of commands) {
      this.sendSerial(cmd + "\n");
    }
    await new Promise((r) => setTimeout(r, 300));
  }

  // ── State management ──────────────────────────────────────────────

  async saveState(): Promise<ArrayBuffer> {
    if (!this.emulator) throw new Error("VM not running");
    return this.emulator.save_state();
  }

  destroy(): void {
    console.log("[LinuxVM] destroy() called, emulator exists:", !!this.emulator);
    if (this.emulator) {
      this.emulator.destroy();
      this.emulator = null;
      this.bashrcInstalled = false;
      this.serialText = "";
      this.bootResolve = null;

      // Remove the v86-screen container so a fresh VM gets a clean one
      const screen = document.getElementById("v86-screen");
      if (screen) {
        screen.remove();
        console.log("[LinuxVM] Removed stale #v86-screen element");
      }

      console.log("[LinuxVM] Emulator destroyed and state reset");
    }
  }

  private async urlExists(url: string): Promise<boolean> {
    try {
      const resp = await fetch(url, { method: "HEAD" });
      return resp.ok;
    } catch {
      return false;
    }
  }
}
