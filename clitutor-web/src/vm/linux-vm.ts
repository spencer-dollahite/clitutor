/**
 * v86 wrapper: boot Alpine Linux, serial I/O, file read/write.
 *
 * Uses the official v86 approach: i386 Alpine rootfs served via 9p over HTTP,
 * with bzImage/initramfs loaded from the filesystem. A state snapshot enables
 * near-instant boot on return visits.
 */

import { generateBashrc } from "./bashrc";

export interface LinuxVMOptions {
  wasmPath?: string;
  biosPath?: string;
  vgaBiosPath?: string;
  /** Base URL for 9p flat filesystem (content-addressed files). */
  fsBaseUrl?: string;
  /** Path to fs.json manifest generated by fs2json.py. */
  fsManifest?: string;
  /** Path to pre-booted state snapshot (optional, enables fast boot). */
  statePath?: string;
  /** Memory in bytes. 512 MB works well for Alpine. */
  memorySize?: number;
  /** Network relay WebSocket URL (null = no networking). */
  networkRelay?: string | null;
}

const BASE = import.meta.env.BASE_URL;

const DEFAULT_OPTS: Required<LinuxVMOptions> = {
  wasmPath: `${BASE}v86/v86.wasm`,
  biosPath: `${BASE}v86/seabios.bin`,
  vgaBiosPath: `${BASE}v86/vgabios.bin`,
  fsBaseUrl: `${BASE}v86/alpine-rootfs-flat/`,
  fsManifest: `${BASE}v86/alpine-fs.json`,
  statePath: `${BASE}v86/alpine-state.bin`,
  memorySize: 512 * 1024 * 1024,
  networkRelay: null,
};

/**
 * Kernel cmdline for 9p root mount.
 * - root=host9p: mount the v86 9p share as root
 * - rootfstype=9p: use 9p filesystem driver
 * - rootflags: virtio transport, loose caching for performance
 * - modules=virtio_pci: load virtio PCI driver in initramfs
 * - tsc=reliable: trust the TSC (avoids slowdowns from TSC calibration)
 * - console=ttyS0: serial console output
 */
const KERNEL_CMDLINE =
  "rw root=host9p rootfstype=9p rootflags=trans=virtio,cache=loose " +
  "modules=virtio_pci tsc=reliable console=ttyS0";

export class LinuxVM {
  private emulator: V86 | null = null;
  private opts: Required<LinuxVMOptions>;
  private onSerialByte: ((byte: number) => void) | null = null;
  private bootResolve: (() => void) | null = null;
  private serialText = "";
  private bashrcInstalled = false;

  constructor(opts: LinuxVMOptions = {}) {
    this.opts = { ...DEFAULT_OPTS, ...opts };
  }

  /**
   * Boot the VM. Returns once the emulator is started (not once the shell
   * is ready — use waitForShell() for that).
   */
  async boot(onSerial: (byte: number) => void): Promise<void> {
    this.onSerialByte = onSerial;

    const hasState = await this.urlExists(this.opts.statePath);
    const hasFs = await this.urlExists(this.opts.fsManifest);

    if (!hasFs) {
      throw new Error(
        "Alpine rootfs not found. Run 'npm run build-rootfs' first. " +
        `Expected: ${this.opts.fsManifest}`,
      );
    }

    // Hidden VGA container required by v86 internals even for serial-only
    let screenContainer = document.getElementById("v86-screen");
    if (!screenContainer) {
      screenContainer = document.createElement("div");
      screenContainer.id = "v86-screen";
      screenContainer.style.display = "none";
      screenContainer.innerHTML =
        '<div style="white-space:pre;font:14px monospace;line-height:14px"></div>' +
        '<canvas style="display:none"></canvas>';
      document.body.appendChild(screenContainer);
    }

    const v86Options: V86Options = {
      wasm_path: this.opts.wasmPath,
      memory_size: this.opts.memorySize,
      vga_memory_size: 8 * 1024 * 1024,
      screen_container: screenContainer,
      disable_keyboard: true,
      disable_mouse: true,
      disable_speaker: true,
      acpi: false,
      autostart: true,
      bios: { url: this.opts.biosPath },
      vga_bios: { url: this.opts.vgaBiosPath },
      filesystem: {
        baseurl: this.opts.fsBaseUrl,
        basefs: this.opts.fsManifest,
      },
    };

    if (hasState) {
      v86Options.initial_state = { url: this.opts.statePath };
    } else {
      v86Options.bzimage_initrd_from_filesystem = true;
      v86Options.cmdline = KERNEL_CMDLINE;
    }

    if (this.opts.networkRelay) {
      v86Options.network_relay_url = this.opts.networkRelay;
    }

    this.emulator = new V86(v86Options);

    // Expose on window for state snapshot generation
    (window as any).__vm = this.emulator;

    // Wire serial output
    this.emulator.add_listener("serial0-output-byte", (byte: number) => {
      this.onSerialByte?.(byte);

      // Track serial text to detect shell prompt for auto-setup
      this.serialText += String.fromCharCode(byte);
      if (this.serialText.length > 500) {
        this.serialText = this.serialText.slice(-200);
      }
      this.checkReady();
    });

    // When restoring from snapshot, the shell is idle — send Enter to
    // trigger a prompt reprint so checkReady() can detect it.
    if (hasState) {
      this.emulator.add_listener("emulator-started", () => {
        setTimeout(() => {
          this.emulator?.serial0_send("\n");
        }, 500);
      });
    }
  }

  /**
   * Wait until the shell prompt appears, then install our custom bashrc.
   * Call this after boot() to set up the sentinel machinery.
   */
  waitForShell(): Promise<void> {
    return new Promise((resolve) => {
      if (this.bashrcInstalled) {
        resolve();
        return;
      }
      this.bootResolve = resolve;
      // Check immediately in case we already have a prompt
      this.checkReady();
    });
  }

  private checkReady(): void {
    if (this.bashrcInstalled || !this.bootResolve) return;

    if (
      this.serialText.includes("localhost:~#") ||
      this.serialText.includes("clitutor:~#") ||
      this.serialText.includes("localhost login:") ||
      this.serialText.includes("~ #") ||
      this.serialText.includes(":~$ ") ||
      /\n(localhost|clitutor)[^ ]*[#$] $/.test(this.serialText)
    ) {
      this.installBashrcNow();
    }
  }

  private async installBashrcNow(): Promise<void> {
    if (this.bashrcInstalled) return;
    this.bashrcInstalled = true;

    // Small delay for prompt to settle
    await new Promise((r) => setTimeout(r, 500));

    // Write bashrc to /root/ (exists in 9p base image) — the bashrc itself
    // sets HOME=/home/student and cd's there.  We create /home/student via
    // serial since v86's create_file API can't write to paths outside the
    // base image's directory tree.
    const bashrc = generateBashrc("/home/student", "student", "clitutor");
    await this.writeFile("/root/.clitutor_bashrc", bashrc);
    this.sendSerial("mkdir -p /home/student; . /root/.clitutor_bashrc 2>/dev/null\n");

    // Mark VM as ready (used by generate-state.mjs)
    (window as any).__vmReady = true;

    // Resolve the waitForShell promise after bashrc takes effect
    if (this.bootResolve) {
      const resolve = this.bootResolve;
      this.bootResolve = null;
      setTimeout(() => resolve(), 800);
    }
  }

  // ── Serial I/O ────────────────────────────────────────────────────

  sendSerial(data: string): void {
    if (!this.emulator) return;
    this.emulator.serial0_send(data);
  }

  sendSerialBytes(bytes: number[]): void {
    if (!this.emulator) return;
    for (const b of bytes) {
      this.emulator.serial0_send(String.fromCharCode(b));
    }
  }

  // ── Filesystem operations ─────────────────────────────────────────

  async writeFile(path: string, content: string): Promise<void> {
    if (!this.emulator) return;
    const encoder = new TextEncoder();
    await this.emulator.create_file(path, encoder.encode(content));
  }

  async readFile(path: string): Promise<string> {
    if (!this.emulator) return "";
    try {
      const data = await this.emulator.read_file(path);
      return new TextDecoder().decode(data);
    } catch {
      return "";
    }
  }

  async fileExists(path: string): Promise<boolean> {
    if (!this.emulator) return false;
    try {
      await this.emulator.read_file(path);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Run a command via serial and read result from a temp file.
   * Used for filesystem validation checks (not for interactive commands).
   */
  async execCommand(cmd: string): Promise<string> {
    const tag = `_ct_${Date.now()}`;
    const outFile = `/tmp/${tag}`;

    this.sendSerial(`${cmd} > ${outFile} 2>&1\n`);
    await new Promise((r) => setTimeout(r, 500));
    const result = await this.readFile(outFile);
    this.sendSerial(`rm -f ${outFile}\n`);
    return result;
  }

  async hasDirWithFile(root: string): Promise<boolean> {
    const result = await this.execCommand(
      `find ${root} -mindepth 2 -maxdepth 2 -type f 2>/dev/null | head -1`,
    );
    return result.trim().length > 0;
  }

  async findFileContaining(root: string, text: string): Promise<boolean> {
    const escaped = text.replace(/'/g, "'\\''");
    const result = await this.execCommand(
      `grep -rl '${escaped}' ${root} 2>/dev/null | head -1`,
    );
    return result.trim().length > 0;
  }

  // ── State management ──────────────────────────────────────────────

  async saveState(): Promise<ArrayBuffer> {
    if (!this.emulator) throw new Error("VM not running");
    return this.emulator.save_state();
  }

  destroy(): void {
    if (this.emulator) {
      this.emulator.destroy();
      this.emulator = null;
      this.bashrcInstalled = false;
      this.serialText = "";
      this.bootResolve = null;

      // Remove the v86-screen container so a fresh VM gets a clean one
      const screen = document.getElementById("v86-screen");
      if (screen) screen.remove();
    }
  }

  private async urlExists(url: string): Promise<boolean> {
    try {
      const resp = await fetch(url, { method: "HEAD" });
      return resp.ok;
    } catch {
      return false;
    }
  }
}
