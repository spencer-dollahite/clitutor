/**
 * v86 wrapper: boot Alpine Linux, serial I/O, file read/write.
 *
 * Uses the official v86 approach: i386 Alpine rootfs served via 9p over HTTP,
 * with bzImage/initramfs loaded from the filesystem. A state snapshot enables
 * near-instant boot on return visits.
 */

import { generateBashrc } from "./bashrc";

export interface LinuxVMOptions {
  wasmPath?: string;
  biosPath?: string;
  vgaBiosPath?: string;
  /** Base URL for 9p flat filesystem (content-addressed files). */
  fsBaseUrl?: string;
  /** Path to fs.json manifest generated by fs2json.py. */
  fsManifest?: string;
  /** Path to pre-booted state snapshot (optional, enables fast boot). */
  statePath?: string;
  /** Memory in bytes. 512 MB works well for Alpine. */
  memorySize?: number;
  /** Network relay WebSocket URL (null = no networking). */
  networkRelay?: string | null;
}

const BASE = import.meta.env.BASE_URL;

const DEFAULT_OPTS: Required<LinuxVMOptions> = {
  wasmPath: `${BASE}v86/v86.wasm`,
  biosPath: `${BASE}v86/seabios.bin`,
  vgaBiosPath: `${BASE}v86/vgabios.bin`,
  fsBaseUrl: `${BASE}v86/alpine-rootfs-flat/`,
  fsManifest: `${BASE}v86/alpine-fs.json`,
  statePath: `${BASE}v86/alpine-state.bin`,
  memorySize: 512 * 1024 * 1024,
  networkRelay: null,
};

/**
 * Kernel cmdline for 9p root mount.
 * - root=host9p: mount the v86 9p share as root
 * - rootfstype=9p: use 9p filesystem driver
 * - rootflags: virtio transport, loose caching for performance
 * - modules=virtio_pci: load virtio PCI driver in initramfs
 * - tsc=reliable: trust the TSC (avoids slowdowns from TSC calibration)
 * - console=ttyS0: serial console output
 */
const KERNEL_CMDLINE =
  "rw root=host9p rootfstype=9p rootflags=trans=virtio,cache=loose " +
  "modules=virtio_pci tsc=reliable console=ttyS0";

export class LinuxVM {
  private emulator: V86 | null = null;
  private opts: Required<LinuxVMOptions>;
  private onSerialByte: ((byte: number) => void) | null = null;
  private bootResolve: (() => void) | null = null;
  private serialText = "";
  private bashrcInstalled = false;

  constructor(opts: LinuxVMOptions = {}) {
    this.opts = { ...DEFAULT_OPTS, ...opts };
  }

  /**
   * Boot the VM. Returns once the emulator is started (not once the shell
   * is ready — use waitForShell() for that).
   */
  async boot(onSerial: (byte: number) => void): Promise<void> {
    this.onSerialByte = onSerial;

    const hasState = await this.urlExists(this.opts.statePath);
    const hasFs = await this.urlExists(this.opts.fsManifest);

    if (!hasFs) {
      throw new Error(
        "Alpine rootfs not found. Run 'npm run build-rootfs' first. " +
        `Expected: ${this.opts.fsManifest}`,
      );
    }

    // Hidden VGA container required by v86 internals even for serial-only
    let screenContainer = document.getElementById("v86-screen");
    if (!screenContainer) {
      screenContainer = document.createElement("div");
      screenContainer.id = "v86-screen";
      screenContainer.style.display = "none";
      screenContainer.innerHTML =
        '<div style="white-space:pre;font:14px monospace;line-height:14px"></div>' +
        '<canvas style="display:none"></canvas>';
      document.body.appendChild(screenContainer);
    }

    const v86Options: V86Options = {
      wasm_path: this.opts.wasmPath,
      memory_size: this.opts.memorySize,
      vga_memory_size: 8 * 1024 * 1024,
      screen_container: screenContainer,
      disable_keyboard: true,
      disable_mouse: true,
      disable_speaker: true,
      acpi: false,
      autostart: true,
      bios: { url: this.opts.biosPath },
      vga_bios: { url: this.opts.vgaBiosPath },
      filesystem: {
        baseurl: this.opts.fsBaseUrl,
        basefs: this.opts.fsManifest,
      },
    };

    if (hasState) {
      v86Options.initial_state = { url: this.opts.statePath };
    } else {
      v86Options.bzimage_initrd_from_filesystem = true;
      v86Options.cmdline = KERNEL_CMDLINE;
    }

    if (this.opts.networkRelay) {
      v86Options.network_relay_url = this.opts.networkRelay;
    }

    this.emulator = new V86(v86Options);

    // Expose on window for state snapshot generation
    (window as any).__vm = this.emulator;

    // Wire serial output
    this.emulator.add_listener("serial0-output-byte", (byte: number) => {
      this.onSerialByte?.(byte);

      // Track serial text to detect shell prompt for auto-setup
      this.serialText += String.fromCharCode(byte);
      if (this.serialText.length > 500) {
        this.serialText = this.serialText.slice(-200);
      }
      this.checkReady();
    });

    // When restoring from snapshot, the shell is idle — send Enter to
    // trigger a prompt reprint so checkReady() can detect it.
    if (hasState) {
      this.emulator.add_listener("emulator-started", () => {
        setTimeout(() => {
          this.emulator?.serial0_send("\n");
        }, 500);
      });
    }
  }

  /**
   * Wait until the shell prompt appears, then install our custom bashrc.
   * Call this after boot() to set up the sentinel machinery.
   */
  waitForShell(): Promise<void> {
    return new Promise((resolve) => {
      if (this.bashrcInstalled) {
        resolve();
        return;
      }
      this.bootResolve = resolve;
      // Check immediately in case we already have a prompt
      this.checkReady();
    });
  }

  private checkReady(): void {
    if (this.bashrcInstalled || !this.bootResolve) return;

    if (
      this.serialText.includes("localhost:~#") ||
      this.serialText.includes("clitutor:~#") ||
      this.serialText.includes("localhost login:") ||
      this.serialText.includes("~ #") ||
      this.serialText.includes(":~$ ") ||
      /\n(localhost|clitutor)[^ ]*[#$] $/.test(this.serialText)
    ) {
      this.installBashrcNow();
    }
  }

  private async installBashrcNow(): Promise<void> {
    if (this.bashrcInstalled) return;
    this.bashrcInstalled = true;

    // Small delay for prompt to settle
    await new Promise((r) => setTimeout(r, 500));

    // Write bashrc to /root/ (exists in 9p base image) — the bashrc itself
    // sets HOME=/home/student and cd's there.  We create /home/student via
    // serial since v86's create_file API can't write to paths outside the
    // base image's directory tree.
    const bashrc = generateBashrc("/home/student", "student", "clitutor");
    await this.writeFile("/root/.clitutor_bashrc", bashrc);
    this.sendSerial("mkdir -p /home/student; . /root/.clitutor_bashrc 2>/dev/null\n");

    // Mark VM as ready (used by generate-state.mjs)
    (window as any).__vmReady = true;

    // Resolve the waitForShell promise after bashrc takes effect
    if (this.bootResolve) {
      const resolve = this.bootResolve;
      this.bootResolve = null;
      setTimeout(() => resolve(), 800);
    }
  }

  // ── Serial I/O ────────────────────────────────────────────────────

  sendSerial(data: string): void {
    if (!this.emulator) return;
    this.emulator.serial0_send(data);
  }

  sendSerialBytes(bytes: number[]): void {
    if (!this.emulator) return;
    for (const b of bytes) {
      this.emulator.serial0_send(String.fromCharCode(b));
    }
  }

  // ── Filesystem operations ─────────────────────────────────────────

  async writeFile(path: string, content: string): Promise<void> {
    if (!this.emulator) return;
    const encoder = new TextEncoder();
    await this.emulator.create_file(path, encoder.encode(content));
  }

  async readFile(path: string): Promise<string> {
    if (!this.emulator) return "";
    try {
      const data = await this.emulator.read_file(path);
      return new TextDecoder().decode(data);
    } catch {
      return "";
    }
  }

  async fileExists(path: string): Promise<boolean> {
    if (!this.emulator) return false;
    try {
      await this.emulator.read_file(path);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Access v86's internal 9p filesystem object.
   * This is the host-side inode tree — updated in real-time as the guest
   * creates/deletes files via 9p protocol messages.  No cache issues,
   * no serial commands, no timing.
   */
  private get9pFs(): any {
    return (this.emulator?.v86?.cpu?.devices?.virtio_9p as any)?.fs ?? null;
  }

  /**
   * Check if any immediate subdirectory of `root` contains a regular file.
   * Walks v86's host-side 9p inode tree directly (2 levels deep).
   *
   * Example: root=/home/student, user runs `mkdir foo && touch foo/bar`
   *   → finds inode for /home/student
   *   → iterates direntries: finds "foo" (directory)
   *   → iterates foo's direntries: finds "bar" (regular file) → true
   */
  async hasDirWithFile(root: string): Promise<boolean> {
    const fs = this.get9pFs();
    if (!fs) return false;

    const rootResult = fs.SearchPath(root);
    if (!rootResult || rootResult.id === -1) return false;

    const rootInode = fs.inodes[rootResult.id];
    if (!rootInode?.direntries) return false;

    // Level 1: immediate children of root — look for directories
    for (const [name, childId] of rootInode.direntries) {
      if (name === "." || name === "..") continue;
      const childMode = fs.inodes[childId]?.mode ?? 0;
      if ((childMode & 0xF000) !== 0x4000) continue; // S_IFDIR = 0x4000

      // Level 2: entries inside the subdirectory — look for regular files
      const childInode = fs.inodes[childId];
      if (!childInode?.direntries) continue;
      for (const [entryName, entryId] of childInode.direntries) {
        if (entryName === "." || entryName === "..") continue;
        const entryMode = fs.inodes[entryId]?.mode ?? 0;
        if ((entryMode & 0xF000) === 0x8000) return true; // S_IFREG = 0x8000
      }
    }
    return false;
  }

  /**
   * Check if any file under `root` (recursively) contains the given text.
   * Walks v86's host-side 9p inode tree and reads file contents via
   * emulator.read_file().
   */
  async findFileContaining(root: string, text: string): Promise<boolean> {
    if (!this.emulator) return false;
    const fs = this.get9pFs();
    if (!fs) return false;

    const rootResult = fs.SearchPath(root);
    if (!rootResult || rootResult.id === -1) return false;

    return this.searchTreeForContent(fs, rootResult.id, root, text);
  }

  /**
   * Recursively search the 9p inode tree for a regular file containing `text`.
   */
  private async searchTreeForContent(
    fs: any, dirId: number, dirPath: string, text: string,
  ): Promise<boolean> {
    const inode = fs.inodes[dirId];
    if (!inode?.direntries) return false;

    for (const [name, childId] of inode.direntries) {
      if (name === "." || name === "..") continue;
      const childPath = dirPath + "/" + name;
      const childMode = fs.inodes[childId]?.mode ?? 0;
      const fileType = childMode & 0xF000;

      if (fileType === 0x8000) {
        // Regular file — read and check content
        try {
          const data = await this.emulator!.read_file(childPath);
          const content = new TextDecoder().decode(data);
          if (content.includes(text)) return true;
        } catch {
          // Unreadable — skip
        }
      } else if (fileType === 0x4000) {
        // Directory — recurse
        if (await this.searchTreeForContent(fs, childId, childPath, text)) {
          return true;
        }
      }
    }
    return false;
  }

  // ── State management ──────────────────────────────────────────────

  async saveState(): Promise<ArrayBuffer> {
    if (!this.emulator) throw new Error("VM not running");
    return this.emulator.save_state();
  }

  destroy(): void {
    if (this.emulator) {
      this.emulator.destroy();
      this.emulator = null;
      this.bashrcInstalled = false;
      this.serialText = "";
      this.bootResolve = null;

      // Remove the v86-screen container so a fresh VM gets a clean one
      const screen = document.getElementById("v86-screen");
      if (screen) screen.remove();
    }
  }

  private async urlExists(url: string): Promise<boolean> {
    try {
      const resp = await fetch(url, { method: "HEAD" });
      return resp.ok;
    } catch {
      return false;
    }
  }
}
